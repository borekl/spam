package SPAM::Model::SNMP;

# code for interfacing with SNMP and interpreting its data; this class needs to
# be instantiated on a per-host basis so that all indices are properly unique

use Moo;
use strict;
use warnings;
use experimental 'signatures';
use Carp;

use SPAM::Config;
use SPAM::Misc qw(hash_iterator);

with 'SPAM::Role::MessageCallback';

# data retrieved from the host via SNMP; at this moment these are trees
# generated by snmp_get_object() and saved either under {MIB_NAME} or
# under {MIB_NAME}{VLAN_NO} (ie. the same was stored in %swdata). This should
# probably be improved upon later.
has _d => ( is => 'ro', default => sub {{}} );

with 'SPAM::Model::SNMP::IfTable';
with 'SPAM::Model::SNMP::Platform';
with 'SPAM::Model::SNMP::Location';
with 'SPAM::Model::SNMP::EntityTree';
with 'SPAM::Model::SNMP::PortTable';
with 'SPAM::Model::SNMP::Bridge';
with 'SPAM::Model::SNMP::TrunkVlans';
with 'SPAM::Model::SNMP::ActiveVlans';
with 'SPAM::Model::SNMP::PortFlags';
with 'SPAM::Model::SNMP::Boottime';
with 'SPAM::Model::SNMP::VmMembershipTable';
with 'SPAM::Model::SNMP::CafSessionTable';

# return list of MIBs loaded in this instance
sub mibs ($self) { keys %{$self->_d} }

# return list of loaded objects in a MIB
sub objects ($self, $mib) { keys %{$self->_d->{$mib}} }

# return object just by its name, without needing to know MIB name
sub get_object($self, $object_name) {
  foreach my $mib ($self->mibs) {
    foreach my $object ($self->objects($mib)) {
      return $self->_d->{$mib}{$object} if $object_name eq $object;
    }
  }
}

#-------------------------------------------------------------------------------
# invoke callback for every SNMP OID in given SNMP object; the arguments the
# callback receives are transformed into a form suitable for sending to
# database; that is SET and WHERE clauses that can be used directly with
# Mojo::Pg::Database select/update/insert/delete methods (for insert simply
# merge the two arguments)
sub iterate_data ($self, $object_name, $cb)
{
  # find the actual data requested
  my $d = $self->get_object($object_name);
  die 'Invalid SNMP object name in SPAM::Config::iterate_data' unless ref $d;

  # MIB object configuration data, this is needed to know what the indices are
  my $obj_cfg = SPAM::Config->instance->find_object($object_name);

  # commence iteration
  hash_iterator($d, scalar($obj_cfg->index->@*), sub ($leaf, @path) {
    # where clause links indices to their values
    my %where_clause;
    for my $i (0 .. $#path) {
      $where_clause{lc $obj_cfg->index->[$i]} = $path[$i];
    }
    # set clause links fields to their values; values are transformed from SNMP
    # structured values to simple values
    my %set_clause;
    for my $k (keys %$leaf) {
      $set_clause{lc $k} = $leaf->{$k}{enum} // $leaf->{$k}{value} // undef;
    }
    # invoke callback
    $cb->(\%where_clause, \%set_clause, @path);
  });
}

1;
