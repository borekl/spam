package SPAM::Host;

use Moo;
use strict;
use warnings;
use experimental 'signatures';
use Carp;
use Socket;

use SPAM::Config;
use SPAM::Model::PortStatus;

# hostname
has name => (
  is => 'ro',
  required => 1,
  coerce => sub { lc $_[0] },
  isa => sub ($v) {
    die 'DNS resolution failed' unless inet_aton($v);
  }
);

# port list ("dbStatus" in the old structure, in fact a hashref with port names
# as keys)
has ports_db => ( is => 'lazy' );

has ports_db2 => (
  is => 'ro', lazy => 1,
  default => sub ($self) {
    SPAM::Model::PortStatus->new(hostname => $self->name)
  }
);

# data retrieved from the host via SNMP; at this moment these are trees
# generated by snmp_get_object() and saved either under {MIB_NAME} or
# under {MIB_NAME}{VLAN_NO} (ie. the same was stored in %swdata). This should
# probably be improved upon later.
has snmp => ( is => 'ro', default => sub {{}} );

# roles dependent on 'snmp'
with 'SPAM::Host::Location';
with 'SPAM::Host::Platform';
with 'SPAM::Host::Boottime';
with 'SPAM::Host::EntityTree';
with 'SPAM::Host::TrunkVlans';
with 'SPAM::Host::PortFlags';
with 'SPAM::Host::PortToIfIndex';
with 'SPAM::Host::IfIndexToPortIndex';
with 'SPAM::Host::IfIndexToDot1d';

# port statistics
has port_stats => ( is => 'ro', default => sub {{
  p_total => 0,
  p_act => 0,
  p_patch => 0,
  p_illact => 0,
  p_inact => 0,
  p_errdis => 0,
  p_used => undef,
}} );

# message display callback, default is an empty sub doing nothing
has mesg => (
  is => 'ro',
  isa => sub { ref $_[0] },
  default => sub {}
);


#------------------------------------------------------------------------------
# add one port as pulled from database by sql_load_status(); FIXME: this needs
# refactoring
sub add_port ($self, $key, @fields)
{
  carp 'DEPRECATED SPAM::Host->add_port()';
  $fields[0] =~ tr/0/2/;  # ifOperStatus
  $fields[10] =~ tr/0/2/; # ifAdminStatus
  $self->ports_db->{$key} = [ @fields ];
}

#------------------------------------------------------------------------------
# iterate over ports; semantically same as swdata_status_iter() legacy function
sub iterate_ports ($self, $cb)
{
  carp 'DEPRECATED SPAM::Host->iterate_ports()';
  foreach my $portname (keys %{$self->ports_db}) {
    my $r = $cb->($portname, @{$self->ports_db->{$portname}});
    last if $r;
  }
}
#------------------------------------------------------------------------------
sub iterate_ports_db ($self, $cb)
{
  foreach my $portname ($self->ports_db2->list_ports) {
    my $r = $cb->($portname, $self->ports_db2->status->{$portname});
    last if $r;
  }
}

#------------------------------------------------------------------------------
# reimplementation of swdata_status_get() legacy function
sub get_port ($self, $key, $col=undef)
{
  carp 'DEPRECATED SPAM::Host->get_port()';
  if(exists $self->ports_db->{$key}) {
    my $row = $self->ports_db->{$key};
    if(defined $col) {
      return $row->[$col];
    } else {
      return $row;
    }
  } else {
    return undef;
  }
}

#------------------------------------------------------------------------------
sub get_port_db ($self, $key, $col=undef)
{
  if(exists $self->ports_db2->{$key}) {
    my $row = $self->ports_db2->{$key};
    if(defined $col) {
      return $row->{$col};
    } else {
      return $row;
    }
  } else {
    return undef;
  }
}

#------------------------------------------------------------------------------
# add SNMP object
sub add_snmp_object ($self, $mib, $vlan, $object, $data)
{
  if($vlan) {
    $self->snmp->{$mib->name}{$vlan}{$object->name} = $data;
  } else {
    $self->snmp->{$mib->name}{$object->name} = $data;
  }
}

#------------------------------------------------------------------------------
# find and return reference to a snmp entity; trees with VLANs not supported
sub get_snmp_object ($self, $object_name)
{
  my $mibs = $self->snmp;

  foreach my $mib (keys %$mibs) {
    foreach my $object (keys %{$mibs->{$mib}}) {
      return $mibs->{$mib}{$object} if $object_name eq $object;
    }
  }

  return undef;
}


#------------------------------------------------------------------------------
# return true if ifTable AND ifXTable exist
sub has_iftable ($self)
{
  if(
    exists $self->snmp->{'IF-MIB'} &&
    exists $self->snmp->{'IF-MIB'}{'ifTable'} &&
    exists $self->snmp->{'IF-MIB'}{'ifXTable'}
  ) {
    return 1;
  } else {
    return undef;
  }
}

#------------------------------------------------------------------------------
# give list of ports that we have in database, but can no longer see in SNMP
# data
sub vanished_ports ($self)
{
  my @vanished;
  my @in_db = $self->ports_db2->list_ports;

  $self->iterate_ports_db(sub ($pn, $p) {
    push(@vanished, $pn) if (!grep { $_ eq $pn } @in_db)
  });

  return @vanished;
}

#------------------------------------------------------------------------------
# A convenience wrapper for the message display callback 'mesg' that adds
# hostname
sub _m ($self, $message, @args)
{
  $self->mesg->('[' . $self->name . '] ' . $message, @args);
}

#------------------------------------------------------------------------------
# TEMPORARY: Legacy database 'status' loading function, superseded by the
# PortStatus class.
sub _build_ports_db ($self)
{
  my $dbh = SPAM::Config->instance->get_dbi_handle('spam');

  $self->_m('Load status (started)');

  carp 'DEPRECATED sql_load_status';
  die "Database connection failed\n" unless ref $dbh;

  my %ports;

  my $qry = 'SELECT %s FROM status WHERE host = ?';
  my @fields = (
    'portname',
    'status',                        # 0
    'inpkts',                        # 1
    'outpkts',                       # 2
    q{date_part('epoch', lastchg)},  # 3
    q{date_part('epoch', lastchk)},  # 4
    'vlan',                          # 5
    'descr',                         # 6
    'duplex',                        # 7
    'rate',                          # 8
    'flags',                         # 9
    'adminstatus',                   # 10
    'errdis',                        # 11
    q{floor(date_part('epoch',current_timestamp) - date_part('epoch',lastchg))},
    'vlans'                          # 13
  );
  $qry = sprintf($qry, join(',', @fields));
  my $sth = $dbh->prepare($qry);
  $sth->execute($self->name);

  while(my ($portname, @row) = $sth->fetchrow_array) {
    $row[0] =~ tr/0/2/;  # ifOperStatus
    $row[10] =~ tr/0/2/; # ifAdminStatus
    $ports{$portname} = [ @row ];
  }

  $self->_m('Load status (finished)');

  return \%ports;
}

#------------------------------------------------------------------------------
sub poll ($self, $hostname, $hostinfo=undef)
{
  $self->_m('Load status (started)');
  ...;
  $self->_m('Load status (finished)');
}

#==============================================================================

1;
