package SPAM::Host;

use Moo;
use strict;
use warnings;
use experimental 'signatures';

use SPAM::Entity;
use SPAM::EntityTree;

# hostname
has name => (
  is => 'ro',
  required => 1,
  coerce => sub { lc $_[0] },
);

# SNMP sysLocation
has location => ( is => 'lazy' );

# current boottime (derived from SNMP sysUpTimeInstance)
has boottime => ( is => 'lazy' );

# last boottime (loaded from database)
has boottime_prev => ( is => 'rw' );

# platform (loaded SNMP sysObjectID)
has platform => ( is => 'lazy' );

# port list ("dbStatus" in the old structure, in fact a hashref with port names
# as keys)
has ports => ( is => 'ro', default => sub {{}} );

# data retrieved from the host via SNMP; at this moment these are trees
# generated by snmp_get_object() and saved either under {MIB_NAME} or
# under {MIB_NAME}{VLAN_NO} (ie. the same was stored in %swdata). This should
# probably be improved upon later.
has snmp => ( is => 'ro', default => sub {{}} );

# portname to ifindex hash
has port_to_ifindex => ( is => 'rw', predicate => 1 );

# ifIndex to (portModuleIndex, portIndex), some CISCO MIBs use this
has ifindex_to_portindex => ( is => 'rw', predicate => 1 );

# ifIndex to BRIDGE-MIB index
has ifindex_to_dot1d => ( is => 'rw', predicate => 1 );

# processed ENTITY-MIB information (SPAM::EntityTree instance)
has entity_tree => ( is => 'lazy' );

# port statistics
has port_stats => ( is => 'ro', default => sub {{
  p_total => 0,
  p_act => 0,
  p_patch => 0,
  p_illact => 0,
  p_inact => 0,
  p_errdis => 0,
  p_used => undef,
}} );

#==============================================================================

# location builder

sub _build_location ($self)
{
  if(
    %{$self->snmp}
    && $self->snmp->{'SNMPv2-MIB'}
    && $self->snmp->{'SNMPv2-MIB'}{'sysLocation'}
  ) {
    return $self->snmp->{'SNMPv2-MIB'}{'sysLocation'}{0}{value};
  } else {
    return undef;
  }
}

# platform builder

sub _build_platform ($self)
{
  if(
    %{$self->snmp}
    && $self->snmp->{'SNMPv2-MIB'}
    && $self->snmp->{'SNMPv2-MIB'}{'sysObjectID'}
  ) {
    my $platform = $self->snmp->{'SNMPv2-MIB'}{'sysObjectID'}{0}{'value'};
    $platform =~ s/^.*:://;
    return $platform;
  } else {
    return undef;
  }
}

# boottime builder

sub _build_boottime ($self)
{
  if(
    %{$self->snmp}
    && $self->snmp->{'SNMPv2-MIB'}
    && $self->snmp->{'SNMPv2-MIB'}{'sysUpTimeInstance'}
  ) {
    my $uptime = $self->snmp->{'SNMPv2-MIB'}{'sysUpTimeInstance'}{undef}{'value'};
    return time() - int($uptime / 100);
  } else {
    return undef;
  }
}

# return true if the switch seems to have been rebooted since we last checked
# on it; this is slightly imprecise -- the switch returns its uptime as
# timeticks from its boot up and we calculate boot time from local system clock;
# since these two clocks can be misaligned, we're introducing bit of a fudge
# to reduce false alarms

sub is_rebooted ($self)
{
  if($self->boottime && $self->boottime_prev) {
    # 30 is fudge factor to account for imprecise clocks
    if(abs($self->boottime - $self->boottime_prev) > 30) {
      return 1;
    }
  }
  return 0;
}

# add one port as pulled from database by sql_load_status(); FIXME: this needs
# refactoring

sub add_port ($self, $key, @fields)
{
  $fields[0] =~ tr/0/2/;  # ifOperStatus
  $fields[10] =~ tr/0/2/; # ifAdminStatus
  $self->ports->{$key} = [ @fields ];
}

# iterate over ports; semantically same as swdata_status_iter() legacy function

sub iterate_ports ($self, $cb)
{
  foreach my $portname (keys %{$self->ports}) {
    my $r = $cb->($portname, @{$self->ports->{$portname}});
    last if $r;
  }
}

# reimplementation of swdata_status_get() legacy function

sub get_port ($self, $key, $col=undef)
{
  if(exists $self->ports->{$key}) {
    my $row = $self->ports->{$key};
    if(defined $col) {
      return $row->[$col];
    } else {
      return $row;
    }
  } else {
    return undef;
  }
}

# add SNMP object

sub add_snmp_object ($self, $mib, $vlan, $object, $data)
{
  if($vlan) {
    $self->snmp->{$mib->name}{$vlan}{$object->name} = $data;
  } else {
    $self->snmp->{$mib->name}{$object->name} = $data;
  }
}

# find and return reference to a snmp entity; trees with VLANs not supported

sub get_snmp_object ($self, $object_name)
{
  my $mibs = $self->snmp;

  foreach my $mib (%$mibs) {
    foreach my $object (keys %{$mibs->{$mib}}) {
      return $mibs->{$mib}{$object} if $object_name eq $object;
    }
  }

  return undef;
}

# build a hash-tree that represents entPhysicalTable returned by host; the
# elements of the three are SPAM::Entity instances

sub _build_entity_tree ($self)
{
  # ensure the necessary entries exist; if they don't, just bail out
  return undef
  unless
    exists $self->snmp->{'ENTITY-MIB'}
    && exists $self->snmp->{'ENTITY-MIB'}{'entPhysicalTable'};

  #--- convert the ENTITY-MIB into an array of SPAM::Entity instances

  my $ePT = $self->snmp->{'ENTITY-MIB'}{'entPhysicalTable'};
  my $eAMT = $self->snmp->{'ENTITY-MIB'}{'entAliasMappingTable'} // undef;
  my @entries = map {
    SPAM::Entity->new(
      %{$ePT->{$_}},
      entPhysicalIndex => $_,
      ifIndex => $eAMT->{$_}{'0'}{'entAliasMappingIdentifier'}{'value'} // undef,
    )
  } keys %$ePT;

  # finish
  return SPAM::EntityTree->new(entities => \@entries);
}

#==============================================================================

1;
