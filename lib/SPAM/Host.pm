package SPAM::Host;

use Moo;
use strict;
use warnings;
use experimental 'signatures';
use Carp;

use SPAM::Model::PortStatus;

# hostname
has name => (
  is => 'ro',
  required => 1,
  coerce => sub { lc $_[0] },
);

# port list ("dbStatus" in the old structure, in fact a hashref with port names
# as keys)
has ports_db => ( is => 'ro', default => sub {{}}, lazy => 1,
  isa => sub { carp "DEPRECATED ports_db"; 1; }
);

has ports_db2 => (
  is => 'ro', lazy => 1,
  default => sub ($self) {
    SPAM::Model::PortStatus->new(hostname => $self->name)
  }
);

# data retrieved from the host via SNMP; at this moment these are trees
# generated by snmp_get_object() and saved either under {MIB_NAME} or
# under {MIB_NAME}{VLAN_NO} (ie. the same was stored in %swdata). This should
# probably be improved upon later.
has snmp => ( is => 'ro', default => sub {{}} );

# roles dependent on 'snmp'
with 'SPAM::Host::Location';
with 'SPAM::Host::Platform';
with 'SPAM::Host::Boottime';
with 'SPAM::Host::EntityTree';
with 'SPAM::Host::TrunkVlans';
with 'SPAM::Host::PortFlags';
with 'SPAM::Host::PortToIfIndex';
with 'SPAM::Host::IfIndexToPortIndex';

# ifIndex to BRIDGE-MIB index
has ifindex_to_dot1d => ( is => 'rw', predicate => 1 );

# port statistics
has port_stats => ( is => 'ro', default => sub {{
  p_total => 0,
  p_act => 0,
  p_patch => 0,
  p_illact => 0,
  p_inact => 0,
  p_errdis => 0,
  p_used => undef,
}} );

# message display callback
has mesg => ( is => 'ro', predicate => 1, isa => sub { ref $_[0] } );

#==============================================================================

# add one port as pulled from database by sql_load_status(); FIXME: this needs
# refactoring

sub add_port ($self, $key, @fields)
{
  carp 'DEPRECATED SPAM::Host->add_port()';
  $fields[0] =~ tr/0/2/;  # ifOperStatus
  $fields[10] =~ tr/0/2/; # ifAdminStatus
  $self->ports_db->{$key} = [ @fields ];
}

# iterate over ports; semantically same as swdata_status_iter() legacy function

sub iterate_ports ($self, $cb)
{
  carp 'DEPRECATED SPAM::Host->iterate_ports()';
  foreach my $portname (keys %{$self->ports_db}) {
    my $r = $cb->($portname, @{$self->ports_db->{$portname}});
    last if $r;
  }
}

sub iterate_ports_db ($self, $cb)
{
  foreach my $portname ($self->ports_db2->list_ports) {
    my $r = $cb->($portname, $self->ports_db2->status->{$portname});
    last if $r;
  }
}

# reimplementation of swdata_status_get() legacy function

sub get_port ($self, $key, $col=undef)
{
  carp 'DEPRECATED SPAM::Host->get_port()';
  if(exists $self->ports_db->{$key}) {
    my $row = $self->ports_db->{$key};
    if(defined $col) {
      return $row->[$col];
    } else {
      return $row;
    }
  } else {
    return undef;
  }
}

sub get_port_db ($self, $key, $col=undef)
{
  if(exists $self->ports_db2->{$key}) {
    my $row = $self->ports_db2->{$key};
    if(defined $col) {
      return $row->{$col};
    } else {
      return $row;
    }
  } else {
    return undef;
  }
}

# add SNMP object

sub add_snmp_object ($self, $mib, $vlan, $object, $data)
{
  if($vlan) {
    $self->snmp->{$mib->name}{$vlan}{$object->name} = $data;
  } else {
    $self->snmp->{$mib->name}{$object->name} = $data;
  }
}

# find and return reference to a snmp entity; trees with VLANs not supported

sub get_snmp_object ($self, $object_name)
{
  my $mibs = $self->snmp;

  foreach my $mib (keys %$mibs) {
    foreach my $object (keys %{$mibs->{$mib}}) {
      return $mibs->{$mib}{$object} if $object_name eq $object;
    }
  }

  return undef;
}

# return true if ifTable AND ifXTable exist

sub has_iftable ($self)
{
  if(
    exists $self->snmp->{'IF-MIB'} &&
    exists $self->snmp->{'IF-MIB'}{'ifTable'} &&
    exists $self->snmp->{'IF-MIB'}{'ifXTable'}
  ) {
    return 1;
  } else {
    return undef;
  }
}

#==============================================================================

1;
